'''
Anki Add-on: Cross-Profile Search and Import
version 0.2.1
URL: https://ankiweb.net/shared/info/310394744
GitHub: https://github.com/rsimmons/anki-cropro

This add-on allows you to find and import notes from another profile into your currently loaded profile.
For example, you can make a "sentence bank" profile where you store thousands of cards generated by subs2srs,
and then use this add-on to search for and import cards with certain words into your main profile.
This helps keep your main profile uncluttered and free of large amounts of unneeded media.

MIT License
Copyright (c) 2018 Russel Simmons
Original concept by CalculusAce, with help from Matt VS Japan (@mattvsjapan)

TODO:
- Handle case where user has only one profile
- Review duplicate checking: check by first field, or all fields?
- When matching model is found, verify field count (or entire map?)
'''

import re
from copy import deepcopy

from aqt import mw
from aqt.qt import *
from aqt.utils import showInfo
from anki.utils import stripHTMLMedia
from anki import Collection
from anki.notes import Note

#############################################################################
### BEGIN OPTIONS
#############################################################################

MAX_DISPLAYED_NOTES = 100
ENABLE_DEBUG_LOG = False

#############################################################################
### END OPTIONS
#############################################################################

logfile = None


def logDebug(o):
    if not ENABLE_DEBUG_LOG:
        return

    global logfile
    if not logfile:
        fn = os.path.join(mw.pm.base, 'cropro.log')
        logfile = open(fn, 'a')
    logfile.write(str(o) + '\n')
    logfile.flush()


# backported from Anki 2.1 anki/utils.py
def htmlToTextLine(s):
    s = s.replace("<br>", " ")
    s = s.replace("<br />", " ")
    s = s.replace("<div>", " ")
    s = s.replace("\n", " ")
    s = re.sub("\[sound:[^]]+\]", "", s)
    s = re.sub("\[\[type:[^]]+\]\]", "", s)
    s = stripHTMLMedia(s)
    s = s.strip()
    return s


def getOtherProfileNames():
    profiles = mw.pm.profiles()
    profiles.remove(mw.pm.name)
    return profiles


def openProfileCollection(name):
    # NOTE: this code is based on aqt/profiles.py; we can't really re-use what's there
    collectionFilename = os.path.join(mw.pm.base, name, 'collection.anki2')
    return Collection(collectionFilename)


class MainDialog(QDialog):
    def __init__(self):
        super(MainDialog, self).__init__()

        self.otherProfileName = None
        self.otherProfileCollection = None

        self.initUI()

    def initUI(self):
        self.otherProfileDeckCombo = QComboBox()

        self.otherProfileCombo = QComboBox()
        otherProfileNames = getOtherProfileNames()
        if otherProfileNames:
            self.otherProfileCombo.addItems(otherProfileNames)
            self.otherProfileCombo.currentIndexChanged.connect(self.otherProfileComboChange)
            self.handleSelectOtherProfile(otherProfileNames[0])

        otherProfileDeckRow = QHBoxLayout()
        otherProfileDeckRow.addWidget(QLabel('Import From Profile:'))
        otherProfileDeckRow.addWidget(self.otherProfileCombo)
        otherProfileDeckRow.addWidget(QLabel('Deck:'))
        otherProfileDeckRow.addWidget(self.otherProfileDeckCombo)
        otherProfileDeckRow.addStretch(1)

        self.filterEdit = QLineEdit()
        self.filterEdit.setPlaceholderText('<text to filter by>')

        filterButton = QPushButton('Filter')

        filterRow = QHBoxLayout()
        filterRow.addWidget(self.filterEdit)
        filterRow.addWidget(filterButton)

        self.noteCountLabel = QLabel('')

        self.noteListView = QListView()
        self.noteListView.setResizeMode(self.noteListView.Fixed)
        self.noteListView.setEditTriggers(self.noteListView.NoEditTriggers)
        self.noteListModel = QStandardItemModel(self.noteListView)
        self.noteListView.setModel(self.noteListModel)
        self.noteListView.setSelectionMode(self.noteListView.ExtendedSelection)
        self.noteListView.doubleClicked.connect(self.doImport)

        currentProfileNameLabel = QLabel(mw.pm.name)
        currentProfileNameLabelFont = QFont()
        currentProfileNameLabelFont.setBold(True)
        currentProfileNameLabel.setFont(currentProfileNameLabelFont)

        self.currentProfileDeckCombo = QComboBox()
        currentProfileDecks = mw.col.decks.all()
        currentProfileDecks.sort(key=lambda d: d['name'])
        selectedDeckId = mw.col.decks.selected()
        selectedIndex = None
        for idx, deck in enumerate(currentProfileDecks):
            self.currentProfileDeckCombo.addItem(deck['name'], deck['id'])
            if deck['id'] == selectedDeckId:
                selectedIndex = idx
        if selectedIndex is not None:
            self.currentProfileDeckCombo.setCurrentIndex(selectedIndex)

        statsRow = QVBoxLayout()

        self.statSuccessLabel = QLabel()
        self.statSuccessLabel.setStyleSheet('QLabel { color : green; }')
        self.statSuccessLabel.hide()
        statsRow.addWidget(self.statSuccessLabel)

        self.statNoMatchingModelLabel = QLabel()
        self.statNoMatchingModelLabel.setStyleSheet('QLabel { color : red; }')
        self.statNoMatchingModelLabel.hide()
        statsRow.addWidget(self.statNoMatchingModelLabel)

        self.statDupeLabel = QLabel()
        self.statDupeLabel.setStyleSheet('QLabel { color : orange; }')
        self.statDupeLabel.hide()
        statsRow.addWidget(self.statDupeLabel)

        importRow = QHBoxLayout()
        importRow.addWidget(QLabel('Into Profile:'))
        importRow.addWidget(currentProfileNameLabel)
        importRow.addWidget(QLabel('Deck:'))
        importRow.addWidget(self.currentProfileDeckCombo)

        importButton = QPushButton('Import')
        importButton.clicked.connect(self.doImport)

        importRow.addWidget(importButton)
        importRow.addStretch(1)

        mainVbox = QVBoxLayout()
        mainVbox.addLayout(otherProfileDeckRow)
        if not otherProfileNames:
            noOtherProfilesWarningLabel = QLabel('This add-on only works if you have multiple profiles.')
            noOtherProfilesWarningLabel.setStyleSheet('QLabel { color : red; }')
            mainVbox.addWidget(noOtherProfilesWarningLabel)
        mainVbox.addLayout(filterRow)
        mainVbox.addWidget(self.noteCountLabel)
        mainVbox.addWidget(self.noteListView)
        mainVbox.addLayout(statsRow)
        mainVbox.addLayout(importRow)

        self.otherProfileDeckCombo.currentIndexChanged.connect(self.updateNotesList)
        filterButton.clicked.connect(self.updateNotesList)

        self.setLayout(mainVbox)

        self.setWindowTitle('Cross Profile Search and Import')
        self.exec_()

    def otherProfileComboChange(self):
        newProfileName = self.otherProfileCombo.currentText()
        self.handleSelectOtherProfile(newProfileName)

    def updateNotesList(self):
        otherProfileDeckName = self.otherProfileDeckCombo.currentText()
        self.noteListModel.clear()
        foundNoteCount = 0
        displayedNoteCount = 0
        if otherProfileDeckName:
            # deck was selected, fill list

            # build query string
            query = 'deck:"' + otherProfileDeckName + '"'  # quote name in case it has spaces

            # get filter text, if any
            filterText = self.filterEdit.text()
            if filterText:
                query += ' "%s"' % filterText

            noteIds = self.otherProfileCollection.findNotes(query)
            foundNoteCount = len(noteIds)
            limitedNoteIds = noteIds[:MAX_DISPLAYED_NOTES]
            displayedNoteCount = len(limitedNoteIds)
            # TODO: we could try to do this in a single sqlite query, but would be brittle
            for noteId in limitedNoteIds:
                note = self.otherProfileCollection.getNote(noteId)
                item = QStandardItem()
                # item.setText(htmlToTextLine(note.fields[0]))
                item.setText(' | '.join(htmlToTextLine(f) for f in note.fields))
                item.setData(noteId)
                self.noteListModel.appendRow(item)
        else:
            # deck was unselected, leave list cleared
            pass

        if displayedNoteCount == foundNoteCount:
            self.noteCountLabel.setText('%d notes found' % foundNoteCount)
        else:
            self.noteCountLabel.setText('%d notes found (displaying first %d)' % (foundNoteCount, displayedNoteCount))

    def handleSelectOtherProfile(self, name):
        # Close current collection object, if any
        if self.otherProfileCollection:
            self.otherProfileCollection.close()
            self.otherProfileCollection = None

        self.otherProfileName = name
        self.otherProfileCollection = openProfileCollection(name)

        self.otherProfileDeckCombo.clear()
        self.otherProfileDeckCombo.addItems(sorted(self.otherProfileCollection.decks.allNames()))

    def doImport(self):
        logDebug('beginning import')

        currentProfileDeckId = self.currentProfileDeckCombo.itemData(self.currentProfileDeckCombo.currentIndex())
        logDebug('current profile deck id %d' % currentProfileDeckId)

        # get the note ids of all selected notes
        noteIds = [self.noteListModel.itemFromIndex(idx).data() for idx in self.noteListView.selectedIndexes()]

        # clear the selection
        self.noteListView.clearSelection()

        logDebug('importing %d notes' % len(noteIds))

        statSuccess = 0
        statNoMatchingModel = 0
        statDupe = 0

        for nid in noteIds:
            # load the note
            logDebug('import note id %d' % nid)
            otherNote: Note = self.otherProfileCollection.getNote(nid)

            # find the model name of the note
            modelName = otherNote.model().get('name')
            logDebug('model name %r' % modelName)

            # find a model in current profile that matches the name of model from other profile
            matchingModel = mw.col.models.byName(modelName)
            if matchingModel:
                # TODO: ensure that field map is same between two models (or same length?), otherwise skip or error?
                logDebug('matching model found, id %s' % matchingModel['id'])
            else:
                logDebug('no matching model, copying')
                # do deep copy just to be safe. model is a dict, but might be nested
                copiedModel = deepcopy(otherNote.model())
                copiedModel['id'] = 0
                mw.col.models.add(copiedModel)
                matchingModel = copiedModel

            # create a new note object
            newNote = Note(mw.col, matchingModel)
            logDebug('new note %s %s' % (newNote.id, newNote.mid))

            # set the deck that the note will generate cards into
            newNote.model()['did'] = currentProfileDeckId

            # copy field values into new note object
            newNote.fields = otherNote.fields[:]  # list of strings, so clone it

            # check if note is dupe of existing one
            if newNote.dupeOrEmpty():
                logDebug('dupe')
                statDupe += 1
                continue

            # check if there are any media files referenced by the note
            mediaFiles = self.otherProfileCollection.media.filesInStr(otherNote.mid, otherNote.joinedFields())
            logDebug('mediaFiles %s' % (mediaFiles,))
            for fn in mediaFiles:
                fullfn = os.path.join(self.otherProfileCollection.media.dir(), fn)

                # referenced media might not exist, in which case we skip it
                if not os.path.exists(fullfn):
                    continue

                logDebug('copying from %s' % fullfn)
                addedFn = mw.col.media.addFile(fullfn)
                # NOTE: addedFn may differ from fn (name conflict, different contents), in which case we need to update the note.
                if addedFn != fn:
                    logDebug('name conflict')
                    newNote.fields = [f.replace(fn, addedFn) for f in newNote.fields]

            addedCardCount = mw.col.addNote(newNote)

            statSuccess += 1

        if statSuccess:
            mw.requireReset()

        if statSuccess:
            self.statSuccessLabel.setText('%d notes successfully imported' % statSuccess)
            self.statSuccessLabel.show()
        else:
            self.statSuccessLabel.hide()
        if statNoMatchingModel:
            self.statNoMatchingModelLabel.setText(
                '%d notes failed to import because there is no matching Note Type in the current profile' % statNoMatchingModel)
            self.statNoMatchingModelLabel.show()
        else:
            self.statNoMatchingModelLabel.hide()
        if statDupe:
            self.statDupeLabel.setText('%d notes were duplicates, and skipped' % statDupe)
            self.statDupeLabel.show()
        else:
            self.statDupeLabel.hide()

    def reject(self):
        if self.otherProfileCollection:
            self.otherProfileCollection.close()

        mw.maybeReset()

        QDialog.reject(self)


def addMenuItem():
    a = QAction(mw)
    a.setText('Cross Profile Search and Import')
    mw.form.menuTools.addAction(a)
    a.triggered.connect(MainDialog)


addMenuItem()
